(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{268:function(e,a,t){e.exports=t.p+"assets/img/singleton_1.6c47125b.png"},269:function(e,a,t){e.exports=t.p+"assets/img/singleton_2.9ee9a223.png"},270:function(e,a,t){e.exports=t.p+"assets/img/singleton_3.090ff010.png"},290:function(e,a,t){"use strict";t.r(a);var r=t(13),o=Object(r.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"单例模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[e._v("#")]),e._v(" 单例模式")]),e._v(" "),a("blockquote",[a("p",[e._v("保证一个类仅有一个实例，并提供一个访问它的全局访问点。")])]),e._v(" "),a("p",[e._v("业务中更加形象的理解是：只要这是一个全局唯一的功能，都可以使用单例模式。甚至在有经验的前端看来，单例模式就是一种自然而然的写法。比如一个登录弹窗，显然是全局唯一的，无论在项目的哪个地方调用了这个弹窗，都应该始终使用的是这同一个弹窗。")]),e._v(" "),a("h2",{attrs:{id:"场景复现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#场景复现"}},[e._v("#")]),e._v(" 场景复现")]),e._v(" "),a("h3",{attrs:{id:"弹窗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#弹窗"}},[e._v("#")]),e._v(" 弹窗")]),e._v(" "),a("p",[e._v("我经历过的一个场景是，一个卡片列表，点击卡片会弹窗（项目中为antd的Modal），一个时刻只有一个弹窗，弹窗只和这个卡片有值传递，那么这个弹窗要写在哪呢？")]),e._v(" "),a("p",[e._v("有两种方案，一种是基于弹窗和卡片有值传递，那么这个弹窗应该放在卡片组件内。但是这样带来的潜在问题是，有多少个卡片，就会有多少个弹窗。虽然这影响并不大，只会在切换弹窗的时候对弹窗的dom节点反复卸载安装，也不怎么影响性能。当然，这是直觉上的判断，具体还是需要根据Modal组件的实现来判断的。然后我就顺着组件库找到了"),a("code",[e._v("rc-dialog")]),e._v("，稍微看了下源码我就知道不是一时半会能解决的了。所以先来一波逆向！\n在"),a("a",{attrs:{href:"https://dialog-react-component.vercel.app/demo/ant-design",target:"_blank",rel:"noopener noreferrer"}},[e._v("rc-dialog的demo"),a("OutboundLink")],1),e._v("中，可以先浅看一下dom结构：")]),e._v(" "),a("p",[a("img",{attrs:{src:t(268),alt:"rc-dialog的demo的dom结构1"}}),e._v(" "),a("img",{attrs:{src:t(269),alt:"rc-dialog的demo的dom结构2"}})]),e._v(" "),a("p",[e._v("可以发现，有多少个modal（这里叫dialog），就会在body上append几个div，这些div就是modal的container了。我原本预想的是rc-dialog使用单例模式实现全局唯一的一个弹窗，但是组件开发者显然比我考虑的更周全，它这个弹窗是可以呼出另一个弹窗来任意嵌套的。所以并没有限制弹窗数量。但我发现了另一个值得学习的点，modal实现了惰性单例，只有在点击的时候才会创建一个div并append到body上。这样看来，第一种方案modal放在card组件中就不合适了，用户每点一个card，就会在body上append一个div，虽然Chrome很强大，再多点div也不会怎么样，但是在学过设计模式的码农看来就不太好接受了。")]),e._v(" "),a("p",[a("em",[e._v("另外，可能我的同事也发现了这个奇怪的地方，但是他的做法是"),a("code",[e._v("{visible && <Modal visible={visible}>}")]),e._v("，虽然body上最多只有一个modal的container了，但是这样频繁的remove和append。。。Chrome天下第一！")]),e._v("\n第二种方案就是将Modal放在card的同一级，所有的card点击后呼出的都是同一个Modal。这种实现方式下，考虑的props的传递问题更多一点，因为Modal中的内容由card决定，但已经不属于设计模式的范畴了。")]),e._v(" "),a("h3",{attrs:{id:"子菜单"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#子菜单"}},[e._v("#")]),e._v(" 子菜单")]),e._v(" "),a("p",[e._v("菜单是一个十分常见的业务组件，但是基于UI不同，实现方式可能大相庭径。如果没有特殊要求，随手一个"),a("code",[e._v("type Menu = {label:string, value:unknow, children?:Menu[]}")]),e._v("，然后递归渲染，一个简单的菜单就出来了。而我遇到的需求类似于"),a("a",{attrs:{href:"https://preview.pro.antdv.com/dashboard/workplace",target:"_blank",rel:"noopener noreferrer"}},[e._v("antd pro vue"),a("OutboundLink")],1),e._v("的菜单。这里只关注收起状态下一级菜单呼出二级菜单的方式。")]),e._v(" "),a("p",[a("img",{attrs:{src:t(270),alt:"antd pro vue menu"}})]),e._v(" "),a("p",[e._v("细细一想这个二级菜单的交互要注意的功能还不少：")]),e._v(" "),a("ol",[a("li",[e._v("在一级菜单上移动，二级菜单可以认为是瞬时移动到对应的一级菜单旁边的；")]),e._v(" "),a("li",[e._v("鼠标从菜单上移开时，二级菜单不是瞬时消失的，二级菜单和一级菜单并不是紧挨着的，如果是瞬时消失，显然鼠标用于不可能hover到二级菜单上。")])]),e._v(" "),a("p",[e._v("这个二级菜单也有两种实现方式，一种是每一个一级菜单都包含有其二级菜单的dom节点，这样可以把大部分的交互效果用css实现；另一种方式是二级菜单是一个单例容器，根据hover到不同的一级菜单而append不同的子节点。\nantd使用的就是第一种方案，而我则以单例模式的思路实现了效果基本相同的一个menu。👉"),a("a",{attrs:{href:"https://github.com/MatRunner/react-practice",target:"_blank",rel:"noopener noreferrer"}},[e._v("源码"),a("OutboundLink")],1),e._v("。之所以说基本相同，是在“二级菜单只有一个dom容器”的实现下，一级菜单的hover状态改变时，二级菜单可以出现平移效果，antd的菜单则实现不出该效果。\n当然，经过我的事后反思，antd的实现方式的优势更大。扩展性上，嵌套的结构容易实现对多级菜单的渲染，而且各级菜单的相对位置容易计算，单例模式实现的二级菜单是通过js实时计算出二级菜单的位置的，拓展性不佳；性能上来说，antd也更佳，menu渲染完毕后，交互行为大部分是由css来控制的，js基本在控制类名，而单例实现的menu，改变一级菜单就要计算二级菜单的位置，并根据二级菜单的内容对容器内进行dom的增删；虽然这对现代浏览器来说问题不大，但是在极限情况下，菜单层级深，子菜单类别繁多时，性能瓶颈出现的更早。")])])}),[],!1,null,null,null);a.default=o.exports}}]);